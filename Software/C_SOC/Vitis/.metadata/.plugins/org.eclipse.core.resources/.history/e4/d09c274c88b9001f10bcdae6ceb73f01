#include <stdio.h>
#include "platform.h"
#include "lw_usb/GenericMacros.h"
#include "lw_usb/GenericTypeDefs.h"
#include "lw_usb/MAX3421E.h"
#include "lw_usb/USB.h"
#include "lw_usb/usb_ch9.h"
#include "lw_usb/transfer.h"
#include "lw_usb/HID.h"
#include "sleep.h"

#include "xparameters.h"
#include <xgpio.h>
#include "graphics.h"
#include "chess/board.h"
#include "chess/MiniMax.h"
#include <stdbool.h>
extern HID_DEVICE hid_device;

static XGpio Gpio_hex;

static BYTE addr = 1; 				//hard-wired USB address
const char* const devclasses[] = { " Uninitialized", " HID Keyboard", " HID Mouse", " Mass storage" };
const uint8_t mousePixel[20*20] = { 0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0x11,0x11,0x10,0x01,0x11,0x11,0x10,0xff,0xff,0xff,0x11,0x10,0xff,0xff,0x11,0x11,0x10,0xff,0xff,0xff,0x11,0xff,0xff,0xff,0x01,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0xff,0xff,0xff};
static volatile uint8_t* button = XPAR_CLICK_BASEADDR;
static volatile uint8_t* MiniMax = XPAR_PLAYER2_BASEADDR; // Switch 0 Default true
static volatile uint8_t* MiniMaxPlayWhite = XPAR_PLAYER1BLACK_BASEADDR;// Switch 1
static volatile uint8_t* newGame = XPAR_NEWGAME_BASEADDR;


const uint8_t promo_graphics [60*60] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x01,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0x01,0x10,0x10,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xff,0xff,0xff,0xff,0x01,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x10};

int pos[8*8] = {b_rook, b_knight, b_bishop, b_king, b_queen, b_bishop, b_knight, b_rook, b_pawn, b_pawn,b_pawn,b_pawn,b_pawn,b_pawn,b_pawn,b_pawn, -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1, w_pawn, w_pawn,w_pawn,w_pawn,w_pawn,w_pawn,w_pawn,w_pawn, w_rook, w_knight, w_bishop, w_king, w_queen, w_bishop, w_knight, w_rook };

BYTE GetDriverandReport() {
	BYTE i;
	BYTE rcode;
	BYTE device = 0xFF;
	BYTE tmpbyte;

	DEV_RECORD* tpl_ptr;
	xil_printf("Reached USB_STATE_RUNNING (0x40)\n");
	for (i = 1; i < USB_NUMDEVICES; i++) {
		tpl_ptr = GetDevtable(i);
		if (tpl_ptr->epinfo != NULL) {
			xil_printf("Device: %d", i);
			xil_printf("%s \n", devclasses[tpl_ptr->devclass]);
			device = tpl_ptr->devclass;
		}
	}
	//Query rate and protocol
	rcode = XferGetIdle(addr, 0, hid_device.interface, 0, &tmpbyte);
	if (rcode) {   //error handling
		xil_printf("GetIdle Error. Error code: ");
		xil_printf("%x \n", rcode);
	} else {
		xil_printf("Update rate: ");
		xil_printf("%x \n", tmpbyte);
	}
	xil_printf("Protocol: ");
	rcode = XferGetProto(addr, 0, hid_device.interface, &tmpbyte);
	if (rcode) {   //error handling
		xil_printf("GetProto Error. Error code ");
		xil_printf("%x \n", rcode);
	} else {
		xil_printf("%d \n", tmpbyte);
	}
	return device;
}

void printHex (u32 data, unsigned channel)
{
	XGpio_DiscreteWrite (&Gpio_hex, channel, data);
}

void clear(int c, int r) {
	for (int xp = c*60; xp < c*60 + 60; xp+=2)
		for (int yp = r*30; yp < r*30 + 30; yp++)
			if ( (((xp/60)%2 == 1) && ((yp/30)%2 == 0)) || (((xp/60)%2 == 0) && ((yp/30)%2 == 1)) )
				setPixels(xp,yp,0xaa);
			else if ( (((xp/60)%2 == 1) && ((yp/30)%2 == 1)) || (((xp/60)%2 == 0) && ((yp/30)%2 == 0)) )
				setPixels(xp,yp,0x55);
}
int main() {
    init_platform();
    /** Graphics information **/

	// 0xff refers to draw the background color
	// Everything else will just be telling us what color to make it
	// 100 pixel defined mouse graphic


	BYTE rcode;
	BOOT_MOUSE_REPORT buf;

	BYTE runningdebugflag = 0;//flag to dump out a bunch of information when we first get to USB_STATE_RUNNING
	BYTE errorflag = 0; //flag once we get an error device so we don't keep dumping out state info
	BYTE device;
	uint8_t b1[20*20];
	uint8_t b2[20*20];

//	xil_printf("initializing MAX3421E...\n");
	MAX3421E_init();
//	xil_printf("initializing USB...\n");
	USB_init();
	resetBoard(pos);
	createGrid(pos);
	displayBoard(pos);
	refreshScreen();
	createGrid(pos);
	displayBoard(pos);
	refreshScreen();
	int x = 0;
	int y = 0;
	int x1 = 0;
	int x2 = 0;
	int y1 = 0;
	int y2 = 0;
	int screen = 1;
	int xpast = 0;
	int ypast = 0;
	bool clicked = false; // If the mouse is clicking on a square or something
	bool white = true;
	bool moving = false;
	bool firsttime = true;
	int selected;
	int movebuffer[32];
	for (int i = 0; i < 32; i++) {
		movebuffer[i] = -1;
	}
	// check booleans
	bool check = false;
	// Castle Booleans
	bool wrook1 = false;
	bool wrook2 = false;
	bool brook1 = false;
	bool brook2 = false;
	bool bking = false;
	bool wking = false;
	// Pawn just did its first move
	bool pawn =  false;
	// Eunpascant memory
	int lastmove = -1;
	// promoting boolean
	bool promoting = false;

	bool bot = (*MiniMax == 0);
	bool botColor = (*MiniMaxPlayWhite == 1);

	// A move will be encoded as a number
	// selected = 12
	// buffer = 13
	// piece at square 12 moves to square 13
	while (1) {
		// REFRESH GAME
		xil_printf("Bot Mode %d\n",bot);
		xil_printf("Bot Color %d\n",botColor);
		bool gameOver = false;
		int ynew;
		int xnew;
		int oldx = x;
		int oldy = y;
		int c = oldx/60;
		int r = oldy/30;
		// Chess Game Handling State Machine
		// Selecting Piece
		if (clicked == true && promoting == false) {
			clicked = moving;
//			xil_printf("White: %d, Piece: %d\n",white,pos[c+r*8]);
			if ((white && pos[c+r*8] < 0) ||
			 	 (white == false && pos[c+r*8] > 0)){
//				xil_printf("SELECTING\n");
				if (moving == true) // Was previously highlighting a selected square
				{
					if (selected != c+r*8) {
						// UnHighlight legal squares
						for (int ind = 0; ind < 32; ind++) {
							if (movebuffer[ind] == -1) break;
							clear(movebuffer[ind]%8,movebuffer[ind]/8);
							redrawCube(movebuffer[ind]/8,movebuffer[ind]%8,pos);
						}
						clear(selected%8,selected/8);
						redrawCube(selected/8,selected%8, pos);
						refreshScreen();

						for (int ind = 0; ind < 32; ind++) {
							if (movebuffer[ind] == -1) break;
							clear(movebuffer[ind]%8,movebuffer[ind]/8);
							redrawCube(movebuffer[ind]/8,movebuffer[ind]%8,pos);
						}
						clear(selected%8,selected/8);
						redrawCube(selected/8,selected%8, pos);
						// Clear the current move buffer
						for (int i = 0; i < 32; i++) {
							movebuffer[i] = -1;
						}
					}
				}
				selected = c+r*8;
				moving = true;
				clicked = false;
				for (int xp = c*60; xp < c*60 + 60; xp+=2)
					for (int yp = r*30; yp < r*30 + 30; yp++)
						setPixels(xp,yp,0x44);
				redrawCube(r,c, pos);
//				drawObject(x,y,20,20,mousePixel,0x22);

				refreshScreen();
				for (int xp = c*60; xp < c*60 + 60; xp+=2)
					for (int yp = r*30; yp < r*30 + 30; yp++)
						setPixels(xp,yp,0x44);
				redrawCube(r,c, pos);
//				drawObject(x,y,20,20,mousePixel,0x22);

				getMoves(c,r,pos,movebuffer,wrook1,wrook2,brook1,brook2,lastmove, bking, wking, pawn, check );
//				xil_printf("Selected square (%d,%d) which has the following legal moves\n",c,r);
//				for (int ind = 0; ind < 32; ind++) {
//					if (movebuffer[ind] == -1) break;
//					xil_printf("%d, ",movebuffer[ind]);
//				}
//				xil_printf("\n");

				// Highlight legal squares
				for (int ind = 0; ind < 32; ind++) {
					if (movebuffer[ind] == -1) break;
					int c = movebuffer[ind]%8;
					int r = movebuffer[ind]/8;
					for (int xp = c*60; xp < c*60 + 60; xp+=2)
						for (int yp = r*30; yp < r*30 + 30; yp++)
							setPixels(xp,yp,0xbb);
					redrawCube(r,c,pos);
				}
				refreshScreen();
				for (int ind = 0; ind < 32; ind++) {
					if (movebuffer[ind] == -1) break;
					int c = movebuffer[ind]%8;
					int r = movebuffer[ind]/8;
					for (int xp = c*60; xp < c*60 + 60; xp+=2)
						for (int yp = r*30; yp < r*30 + 30; yp++)
							setPixels(xp,yp,0xbb);
					redrawCube(r,c,pos);
				}
			}
		}
		if(bot == true && white == botColor) { // bot playing
			int move;
			int temp[64];
			for (int i = 0; i < 64; i++) temp[i] = pos[i];
			// Need to add alpha = - inf, beta = inf
			int score = minimaxExt(temp,&move,3,white,wrook1,wrook2,wking,
					brook1,brook2,bking,lastmove,pawn,check);
			// This is just because I had some errors before where the board stored in this function
			// got filled with a bunch of garbage after the function not sure if it stack overflowed or not
			// but it works so i wont question it :)
			for (int i = 0; i < 64; i++) pos[i] = temp[i];

			selected = (move%10000)/100;
			int newSquare = move%100;
			r = newSquare/8;
			c = newSquare%8;
			xil_printf("Decided on move %d with a score of %d\n",move,score);
			if(selected/8 == 6 && pos[selected] == w_pawn) {
				pawn = true;
			}else if (selected/8 == 1 && pos[selected] == b_pawn) {
				pawn = true;
			}else {
				pawn = false;
			}

		// Pawn Eunpascant has specail logic
		if(pos[selected] == w_pawn)
		{
			if (r == 2) {  // Eunpasant potential
				if((selected == position(c-1,r+1) && boardAt(c,r,pos) == 0)
						|| (selected == position(c+1,r+1) && boardAt(c,r,pos) == 0) ) {
					pos[c+(r+1)*8] = 0;
					clear(c,r+1);
					refreshScreen();
					clear(c,r+1);
				}
			}
		}

		if(pos[selected] == b_pawn)
			if (r == 5) {  // Eunpasant potential
				if((selected == position(c-1,r-1) && boardAt(c,r,pos) == 0)
					|| (selected == position(c+1,r-1) && boardAt(c,r,pos) == 0) ) {
					pos[c+(r-1)*8] = 0;
					clear(c,r-1);
					refreshScreen();
					clear(c,r-1);
				}
			}
		// Updating castling information
		if (pos[selected] == w_king)
			wking = true;
		if (pos[selected] == b_king)
			bking = true;
		if (pos[selected] == w_rook && selected%8 == 0)
			wrook1 = true;
		if (pos[selected] == w_rook && selected%8 == 7)
			wrook2 = true;
		if (pos[selected] == b_rook && selected%8 == 0)
			brook1 = true;
		if (pos[selected] == b_rook && selected%8 == 7)
			brook2 = true;
		// Castling stuff
		if (pos[selected] == w_king && (position(c+2,r) == selected || position(c-2,r) == selected) ) {
			if (position(c+2,r) == selected) {
				pos[c+r*8] = pos[selected];
				pos[position(c+1,r)] = w_rook;
				pos[position(0,r)] = 0;
				pos[selected] = 0;
				clear(c,r);
				clear(selected%8,selected/8);
				clear(0,selected/8);
				redrawCube(r,c, pos);
				redrawCube(r,c+1, pos);
				refreshScreen();
				clear(c,r);
				clear(selected%8,selected/8);
				clear(0,selected/8);
				redrawCube(r,c, pos);
				redrawCube(r,c+1, pos);
				refreshScreen();

			}else if (position(c-2,r) == selected) {
				pos[c+r*8] = pos[selected];
				pos[position(c-1,r)] = w_rook;
				pos[position(7,r)] = 0;
				pos[selected] = 0;
				clear(c,r);
				clear(selected%8,selected/8);
				clear(7,selected/8);
				redrawCube(r,c, pos);
				redrawCube(r,c-1, pos);
				refreshScreen();
				clear(c,r);
				clear(selected%8,selected/8);
				clear(7,selected/8);
				redrawCube(r,c, pos);
				redrawCube(r,c-1, pos);
				refreshScreen();

			}
		} else if (pos[selected] == b_king && (position(c+2,r) == selected || position(c-2,r) == selected)) {
			if (position(c+2,r) == selected) {
				pos[c+r*8] = pos[selected];
				pos[position(c+1,r)] = b_rook;
				pos[position(0,r)] = 0;
				pos[selected] = 0;

				clear(c,r);
				clear(selected%8,selected/8);
				clear(0,selected/8);
				redrawCube(r,c, pos);
				redrawCube(r,c+1, pos);
				refreshScreen();
				clear(c,r);
				clear(selected%8,selected/8);
				clear(0,selected/8);
				redrawCube(r,c, pos);
				redrawCube(r,c+1, pos);
				refreshScreen();

			}else if (position(c-2,r) == selected) {
				pos[c+r*8] = pos[selected];
				pos[position(c-1,r)] = b_rook;
				pos[position(7,r)] = 0;
				pos[selected] = 0;

				clear(c,r);
				clear(selected%8,selected/8);
				clear(7,selected/8);
				redrawCube(r,c, pos);
				redrawCube(r,c-1, pos);
				refreshScreen();
				clear(c,r);
				clear(selected%8,selected/8);
				clear(7,selected/8);
				redrawCube(r,c, pos);
				redrawCube(r,c-1, pos);
				refreshScreen();

			}
		}else {
			xil_printf("Doing move (%d,%d) to (%d,%d)\n",selected%8,selected/8,c,r);
			if (white) {// See if I captured any black rooks
				if(pos[c+r*8] == b_rook && r == 0) {
					if (c == 0)
						brook1 = true;
					else if (c==7)
						brook2 = true;
				}
			}else {
				if(pos[c+r*8] == w_rook && r == 7) {
					if (c==0) {
						wrook1 = true;
					}else if (c==7) {
						wrook2 = true;
					}
				}
			}
			pos[c+r*8]  = pos[selected];
			pos[selected] = 0;
			if (r == 7 && pos[c+r*8] == b_pawn && botColor == false) {
				int code = move/10000;
				if (code == 1) {
					pos[c+r*8] = b_rook;
				}else if(code == 2) {
					pos[c+r*8] = b_bishop;
				}else if(code == 3) {
					pos[c+r*8] = b_rook;
				}else if(code == 4) {
					pos[c+r*8] = b_queen;
				}
			}else if (r == 0 && pos[c+r*8] == w_pawn && botColor == true) {
				int code = move/10000;
				if (code == 1) {
					pos[c+r*8] = w_rook;
				}else if(code == 2) {
					pos[c+r*8] = w_bishop;
				}else if(code == 3) {
					pos[c+r*8] = w_rook;
				}else if(code == 4) {
					pos[c+r*8] = w_queen;
				}
			}
			clear(c,r);
			clear(selected%8,selected/8);
			redrawCube(r,c, pos);
			refreshScreen();
			clear(c,r);
			clear(selected%8,selected/8);
			redrawCube(r,c, pos);
			xil_printf("Graphics Should have just redrawn\n");
		}


		moving = false;
		clicked = false;
		for (int i = 0; i < 32; i++) {
			movebuffer[i] = -1;
		}

		lastmove = c+r*8;
		white = !botColor; // No longer bots turn
		// Check for Game Over
			check = inCheck(pos,white);
			if(check) {
				if(checkmate(pos,white,pawn,lastmove)) {
					xil_printf("\n\n\n___________________________________________\nCHECKMATE \n");
					if (white) {
						xil_printf("Black Wins!\n\n\n________________________________________\n");
					}else
						xil_printf("White Wins!\n\n\n________________________________________\n");
					gameOver = true;
				}
			} else {
				if(checkmate(pos,white,pawn,lastmove)) {
					xil_printf("\n\n\n___________________________________________\nSTALEMATE \n");
					xil_printf("Everyone Wins!\n\n\n________________________________________\n");
					gameOver = true;
				}
			}

		}
		// Trying to do a move human playing
		else if ((clicked == true && moving && promoting == false)) {
			if (legalMove(movebuffer,c+r*8)) { // Making sure a piece wasnt deselected
				// Have some check here to make sure that the position is part of the legal move buffer
				// TBD
					if(selected/8 == 6 && pos[selected] == w_pawn) {
						pawn = true;
					}else if (selected/8 == 1 && pos[selected] == b_pawn) {
						pawn = true;
					}else {
						pawn = false;
					}
					// UnHighlight legal squares
					for (int ind = 0; ind < 32; ind++) {
						if (movebuffer[ind] == -1) break;
						clear(movebuffer[ind]%8,movebuffer[ind]/8);
						redrawCube(movebuffer[ind]/8,movebuffer[ind]%8,pos);
					}
					refreshScreen();
					// UnHighlight legal squares
					for (int ind = 0; ind < 32; ind++) {
						if (movebuffer[ind] == -1) break;
						clear(movebuffer[ind]%8,movebuffer[ind]/8);
						redrawCube(movebuffer[ind]/8,movebuffer[ind]%8,pos);
					}
					refreshScreen();

				// Pawn Eunpascant has specail logic
				if(pos[selected] == w_pawn)
				{
					if (r == 2) {  // Eunpasant potential
						if((selected == position(c-1,r+1) && boardAt(c,r,pos) == 0)
								|| (selected == position(c+1,r+1) && boardAt(c,r,pos) == 0) ) {
							pos[c+(r+1)*8] = 0;
							clear(c,r+1);
							refreshScreen();
							clear(c,r+1);
						}
					}
				}

				if(pos[selected] == b_pawn)
					if (r == 5) {  // Eunpasant potential
						if((selected == position(c-1,r-1) && boardAt(c,r,pos) == 0)
							|| (selected == position(c+1,r-1) && boardAt(c,r,pos) == 0) ) {
							pos[c+(r-1)*8] = 0;
							clear(c,r-1);
							refreshScreen();
							clear(c,r-1);
						}
					}
				// Updating castling information
				if (pos[selected] == w_king)
					wking = true;
				if (pos[selected] == b_king)
					bking = true;
				if (pos[selected] == w_rook && selected%8 == 0)
					wrook1 = true;
				if (pos[selected] == w_rook && selected%8 == 7)
					wrook2 = true;
				if (pos[selected] == b_rook && selected%8 == 0)
					brook1 = true;
				if (pos[selected] == b_rook && selected%8 == 7)
					brook2 = true;
				// Castling stuff
				if (pos[selected] == w_king && (position(c+2,r) == selected || position(c-2,r) == selected) ) {
					if (position(c+2,r) == selected) {
						pos[c+r*8] = pos[selected];
						pos[position(c+1,r)] = w_rook;
						pos[position(0,r)] = 0;
						pos[selected] = 0;
						clear(c,r);
						clear(selected%8,selected/8);
						clear(0,selected/8);
						redrawCube(r,c, pos);
						redrawCube(r,c+1, pos);
						refreshScreen();
						clear(c,r);
						clear(selected%8,selected/8);
						clear(0,selected/8);
						redrawCube(r,c, pos);
						redrawCube(r,c+1, pos);
						refreshScreen();

					}else if (position(c-2,r) == selected) {
						pos[c+r*8] = pos[selected];
						pos[position(c-1,r)] = w_rook;
						pos[position(7,r)] = 0;
						pos[selected] = 0;
						clear(c,r);
						clear(selected%8,selected/8);
						clear(7,selected/8);
						redrawCube(r,c, pos);
						redrawCube(r,c-1, pos);
						refreshScreen();
						clear(c,r);
						clear(selected%8,selected/8);
						clear(7,selected/8);
						redrawCube(r,c, pos);
						redrawCube(r,c-1, pos);
						refreshScreen();

					}
				} else if (pos[selected] == b_king && (position(c+2,r) == selected || position(c-2,r) == selected)) {
					if (position(c+2,r) == selected) {
						pos[c+r*8] = pos[selected];
						pos[position(c+1,r)] = b_rook;
						pos[position(0,r)] = 0;
						pos[selected] = 0;

						clear(c,r);
						clear(selected%8,selected/8);
						clear(0,selected/8);
						redrawCube(r,c, pos);
						redrawCube(r,c+1, pos);
						refreshScreen();
						clear(c,r);
						clear(selected%8,selected/8);
						clear(0,selected/8);
						redrawCube(r,c, pos);
						redrawCube(r,c+1, pos);
						refreshScreen();

					}else if (position(c-2,r) == selected) {
						pos[c+r*8] = pos[selected];
						pos[position(c-1,r)] = b_rook;
						pos[position(7,r)] = 0;
						pos[selected] = 0;

						clear(c,r);
						clear(selected%8,selected/8);
						clear(7,selected/8);
						redrawCube(r,c, pos);
						redrawCube(r,c-1, pos);
						refreshScreen();
						clear(c,r);
						clear(selected%8,selected/8);
						clear(7,selected/8);
						redrawCube(r,c, pos);
						redrawCube(r,c-1, pos);
						refreshScreen();

					}
				}else {
					xil_printf("Doing move (%d,%d) to (%d,%d)\n",selected%8,selected/8,c,r);
					if (white) {// See if I captured any black rooks
						if(pos[c+r*8] == b_rook && r == 0) {
							if (c == 0)
								brook1 = true;
							else if (c==7)
								brook2 = true;
						}
					}else {
						if(pos[c+r*8] == w_rook && r == 7) {
							if (c==0) {
								wrook1 = true;
							}else if (c==7) {
								wrook2 = true;
							}
						}
					}
					pos[c+r*8]  = pos[selected];
					pos[selected] = 0;
					clear(c,r);
					clear(selected%8,selected/8);
					redrawCube(r,c, pos);
					refreshScreen();
					clear(c,r);
					clear(selected%8,selected/8);
					redrawCube(r,c, pos);
					xil_printf("Graphics Should have just redrawn\n");
					// check to see if any rooks got captured

				}


				moving = false;
				clicked = false;
				for (int i = 0; i < 32; i++) {
					movebuffer[i] = -1;
				}

				lastmove = c+r*8;
				if (pos[c+r*8] == w_pawn && r == 0) {
					promoting = true;
					selected = c+r*8;
					clear(c,r);
					drawObject(c*60,r*30,60,60,promo_graphics,0x11);
					refreshScreen();
					clear(c,r);
					drawObject(c*60,r*30,60,60,promo_graphics,0x11);
				}else if (pos[c+r*8] == b_pawn && r == 7) {
					promoting = true;
					selected = c+r*8;
					clear(c,r);
					drawObject(c*60,r*30,60,60,promo_graphics,0x66);
					refreshScreen();
					clear(c,r);
					drawObject(c*60,r*30,60,60,promo_graphics,0x66);
				}else{// Turn Over
					if(white)
						white = false;
					else
						white = true;
				}
			}

			clicked = false;
			continue;
		}else if(promoting && clicked) {
			if(c+r*8 == selected) {
				int xoff = x-c*60;
				int yoff = y-r*30;
				if(xoff/30 == 0 && yoff/15 == 0) {
					if(white == true) {
						pos[selected] = w_bishop;
						white = false;
					}else {
						pos[selected] = b_bishop;
						white = true;
					}
				}else if(xoff/30 == 0 && yoff/15 > 0) {
					if(white == true) {
						pos[selected] = w_queen;
						white = false;
					}else {
						pos[selected] = b_queen;
						white = true;
					}
				}else if (xoff/30 > 0 && yoff/15 > 0) {
					if(white == true) {
						pos[selected] = w_rook;
						white = false;
					}else {
						pos[selected] = b_rook;
						white = true;
					}
				}else if(xoff/30 > 0 && yoff/15 == 0) {
					if(white == true) {
						pos[selected] = w_knight;
						white = false;
					}else {
						pos[selected] = b_knight;
						white = true;
					}
				}

				clear(selected%8,selected/8);
				redrawCube(r,c,pos);
				refreshScreen();
				clear(selected%8,selected/8);
				redrawCube(r,c,pos);
				refreshScreen();
				promoting = false;

			}
			clicked = false;
		}else {
			clicked = false;
		}

		check = inCheck(pos,white);
		gameOver = false;
		if(check) {
			if(checkmate(pos,white,pawn,lastmove)) {
				xil_printf("\n\n\n___________________________________________\nCHECKMATE \n");
				if (white) {
					xil_printf("Black Wins!\n\n\n________________________________________\n");
				}else
					xil_printf("White Wins!\n\n\n________________________________________\n");
				gameOver = true;
			}
		} else {
			if(checkmate(pos,white,pawn,lastmove)) {
				xil_printf("\n\n\n___________________________________________\nSTALEMATE \n");
				xil_printf("Everyone Wins!\n\n\n________________________________________\n");
				gameOver = true;
			}
		}

		xil_printf("Game Status: %d\n",gameOver);
		if(gameOver) {
			createGrid(pos);
			displayBoard(pos);
			refreshScreen();
			createGrid(pos);
			displayBoard(pos);
			refreshScreen();
		}
		while(gameOver) {
						// Wait for the reset button
						if(*newGame == 1) {
													resetBoard(pos);
													createGrid(pos);
													displayBoard(pos);
													refreshScreen();
													createGrid(pos);
													displayBoard(pos);
													refreshScreen();
													x = 0;
													y = 0;
													x1 = 0;
													x2 = 0;
													y1 = 0;
													y2 = 0;
													screen = 1;
													xpast = 0;
													ypast = 0;
													clicked = false; // If the mouse is clicking on a square or something
													white = true;
													moving = false;
													firsttime = true;
													for (int i = 0; i < 32; i++) {
														movebuffer[i] = -1;
													}
													// check booleans
													check = false;
													// Castle Booleans
													wrook1 = false;
													wrook2 = false;
													brook1 = false;
													brook2 = false;
													bking = false;
													wking = false;
													// Pawn just did its first move
													pawn =  false;
													// Eunpascant memory
													lastmove = -1;
													// promoting boolean
													promoting = false;

													bot = (*MiniMax == 0);
													botColor = (*MiniMaxPlayWhite == 1);
													gameOver = false;
									}
					}


		// USB Handling we want to keep reading until we notice a mouse action
		bool firsttime = true;
		while (clicked == false) {
			// Refresh game first if need to
			if(*newGame == 1) {
							resetBoard(pos);
							createGrid(pos);
							displayBoard(pos);
							refreshScreen();
							createGrid(pos);
							displayBoard(pos);
							refreshScreen();
							x = 0;
							y = 0;
							x1 = 0;
							x2 = 0;
							y1 = 0;
							y2 = 0;
							screen = 1;
							xpast = 0;
							ypast = 0;
							clicked = false; // If the mouse is clicking on a square or something
							white = true;
							moving = false;
							firsttime = true;
							for (int i = 0; i < 32; i++) {
								movebuffer[i] = -1;
							}
							// check booleans
							check = false;
							// Castle Booleans
							wrook1 = false;
							wrook2 = false;
							brook1 = false;
							brook2 = false;
							bking = false;
							wking = false;
							// Pawn just did its first move
							pawn =  false;
							// Eunpascant memory
							lastmove = -1;
							// promoting boolean
							promoting = false;

							bot = (*MiniMax == 0);
							botColor = (*MiniMaxPlayWhite == 1);
							break;
			}
			// Then read from the USB
			MAX3421E_Task();
			USB_Task();
			oldx = x;
			oldy = y;
			c = oldx/60;
		    r = oldy/30;
					if (GetUsbTaskState() == USB_STATE_RUNNING) {
						if (!runningdebugflag) {
							runningdebugflag = 1;
							device = GetDriverandReport();
						} else if (device == 2) {
														if (*button == 1) {
															while(*button == 1) {}
//															xil_printf("Button click registered\n");
															clicked = true;
															break;
														}
							rcode = mousePoll(&buf);
							if (rcode == hrNAK) {
								//NAK means no new data
								continue;
							}
							if(buf.button) {
//								xil_printf("Button click registered\n");
//								buf.button = 0;
								clicked = true;
								break;
							}


							else if (rcode) {
//								xil_printf("Rcode: ");
//								xil_printf("%d \n", rcode);
//								xil_printf("Button:%d\n",buf.button);

								continue;

							}

							// Handles the player Mouse.
							xnew = x + (signed char)buf.Xdispl;
							ynew = y +  (signed char)buf.Ydispl;
//							xil_printf("Coordinate (%d,%d)\t",xnew,ynew);

							if (xnew < 0) {
								xnew = 0;
							}
							if (xnew > 480) {
								if(buf.Xdispl > 0)
									xnew = 480;
								else
									xnew = 0;
							}


							if (ynew < 0) {
								ynew = 0;
							}
							if (ynew > 480) {
								if(buf.Ydispl > 0)
									ynew = 480;
								else
									ynew = 0;
							}

						}
					} else if (GetUsbTaskState() == USB_STATE_ERROR) {

						if (!errorflag) {
							errorflag = 1;
							xil_printf("USB Error State\n");
							//print out string descriptor here
						}
					} else //not in USB running state
					{

						xil_printf("USB task state: ");
						xil_printf("%x\n", GetUsbTaskState());
						if (runningdebugflag) {	//previously running, reset USB hardware just to clear out any funky state, HS/FS etc
							runningdebugflag = 0;
							MAX3421E_init();
							USB_init();
						}
						errorflag = 0;
					}

					if ( (ynew != y && xnew != x) || (rcode != hrNAK) || firsttime) {
						/***** Updating the Mouse graphic and handling any clicking logic  *****/
						firsttime = false;

						x = xnew;
						y = ynew;
						if (x > 460)
							x = 460;
						if (x < 0)
							x = 0;
						if (y > 230)
							y = 230;
						if (y < 0)
							y = 0;

						drawObject(x,y,20,20,mousePixel,0x22);
						refreshScreen();
						for (int xp = oldx; xp < oldx + 20; xp+=2) {
							for (int yp = oldy; yp < oldy + 20; yp++) {
								if (moving && selected == (xp/60+yp/30*8))
									setPixels(xp,yp,0x44);
								else if ( (((xp/60)%2 == 1) && ((yp/30)%2 == 0)) || (((xp/60)%2 == 0) && ((yp/30)%2 == 1)) )
									setPixels(xp,yp,0xaa);
								else if ( (((xp/60)%2 == 1) && ((yp/30)%2 == 1)) || (((xp/60)%2 == 0) && ((yp/30)%2 == 0)) )
									setPixels(xp,yp,0x55);
							}
						}
						// Highlight legal squares
						for (int ind = 0; ind < 32; ind++) {
							if (movebuffer[ind] == -1) break;
							int c = movebuffer[ind]%8;
							int r = movebuffer[ind]/8;
							for (int xp = c*60; xp < c*60 + 60; xp+=2)
								for (int yp = r*30; yp < r*30 + 30; yp++)
										setPixels(xp,yp,0xbb);
							redrawCube(r,c,pos);
						}
						redrawCube(r-1,c-1, pos);
						redrawCube(r-1,c+1, pos);
						redrawCube(r+1,c-1, pos);
						redrawCube(r+1,c+1, pos);
						redrawCube(r,c-1, pos);
						redrawCube(r,c+1, pos);
						redrawCube(r-1,c, pos);
						redrawCube(r+1,c, pos);
						redrawCube(r,c, pos);

						if (promoting && selected/8 == 0){
							clear(selected%8,selected/8);
							drawObject(selected%8*60,selected/8*30,60,60,promo_graphics,0x11);
						}else if (promoting && selected/8 == 7) {
							clear(selected%8,selected/8);
							drawObject(selected%8*60,selected/8*30,60,60,promo_graphics,0x66);
						}
					}
		}




	}
    cleanup_platform();
	return 0;
}
